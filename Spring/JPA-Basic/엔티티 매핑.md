## 1️. 객체와 테이블 매핑
### 1️⃣ `@Entity`
JPA가 관리하여 테이블과 매핑하는 클래스이며, 엔티티라고 한다.

```java
@Entity(name = "USER")  
public class Member {
}
```
`name` 속성은 JPA에서 사용할 엔티티 이름을 지정한다.
기본적으로 클래스 이름을 그대로 사용하기 때문에 같은 클래스 이름이 없을 경우 가급적 기본값을 사용한다.

기본 생성자가 필수여야 한다.
JPA는 엔티티를 조회할 때 개발자가 정의한 생성자를 호출하지 않으며, 리플렉션을 사용하거나 프록시 객체를 생성하거나 바이트코드를 조작한다.
이 경우 JPA는 기본 생성자로 객체를 생성한 이후, 필드에 값을 주입하는 방식을 선택한다.
### 2️⃣ `@Table`
엔티티와 매핑할 테이블을 지정한다.

```java
@Entity  
@Table(name = "MBR")  
public class Member {
}
```
`name` 속성은 매핑할 테이블 이름을 지정한다.
기본값은 엔티티 이름이지만, 엔티티 이름과 다른 테이블 명을 사용할 경우 지정할 수 있다.
```java
@Entity
@Table(uniqueConstraints = {@UniqueConstraint(name = "uk_member_name", columnNames = {"name"})})
public class Member{}
```
```sql
CONSTRAINT_NAME      COLUMN_NAME
--------------------------------
UK_MEMBER_NAME       NAME
```
DDL 생성 시에 유니크 제약 조건을 생성한다.
unique key의 index name을 설정할 수 있다.
## 2. 필드와 컬럼 매핑
### 1️⃣ `@Column`
컬럼을 매핑한다.

#### 1) name
필드와 매핑할 테이블의 컬럼 이름을 정의한다.
기본적으로 객체의 필드 이름을 사용한다.
#### 2) insertable, updatable
등록, 변경 가능 여부를 정의한다.
기본적으로 TRUE를 가진다.
#### 3) nullable
null 값의 허용 여부를 설정한다.
```java
@Entity  
public class Member {  
  
    @Id  
    private Long id;  
  
    @Column(name = "name", nullable = false)  
    private String username;
}
```
```sql
create table Member (
	id bigint not null,
	name varchar(255) not null
	primary key (id)
)
```
false로 설정할 경우 DDL 생성 시에 not null 제약 조건이 붙는다.
#### 4) unique
unique 제약 조건을 걸 경우 사용한다.
```java
@Column(name = "name", nullable = false, unique = true)  
private String username;
```
```
INDEX_NAME           COLUMN_NAME   IS_UNIQUE
--------------------------------------------
CONSTRAINT_INDEX_8   NAME          TRUE
```
이 경우 생성된 index 이름은 쉽게 파악할 수 없다.
따라서 운영 환경에서는 index 이름을 명시할 수 있는 `@Table`의 `uniqueConstraints`를 사용한다.
#### 5) columnDefinition
데이터베이스 컬럼 정보를 직접 줄 수 있다.
특정 DB의 방언과 자바 타입을 사용할 수 있다.
```java
@Entity  
public class Member {  
  
    @Id  
    private Long id;  
  
    @Column(name = "name", columnDefinition = "varchar(100) default 'EMPTY'")  
    private String username;
}
```
```sql
create table Member (
	id bigint not null,
	name varchar(100) default 'EMPTY',
	primary key (id)
)
```
#### 6) length
문자 길이 제약조건을 정의한다.
String 타입에서만 사용할 수 있으며, 기본값은 255이다.
#### 7) precision, scale
BigDecimal 혹은 BigInteger 타입과 같이 큰 숫자나 정밀한 소수를 다루어야 할 때 사용한다.
precision은 소수점을 포함한 전체 자릿수를, scale은 소수의 자릿수를 의미한다.
기본값은 precision은 19, scale은 2이다.
### 2️⃣ `@Temporal`
날짜 타입을 매핑한다.
```java
public enum TemporalType {  
    DATE,  
    TIME,  
    TIMESTAMP;  
  
    private TemporalType() {  
    }  
}
```

최신 하이버네이트에서는 `LocalDate`, `LocalDateTime`을 사용할 수 있기 때문에 생략이 가능하다.
### 3️⃣ `@Enumerated`
enum 타입을 매핑한다.

```java
public enum EnumType {  
    ORDINAL,  
    STRING;  
  
    private EnumType() {  
    }  
}
```
enum 타입에는 두 가지가 있다.
`ORDINAL`은 enum 순서를 데이터베이스에 저장하고, `STRING`은 enum 이름을 데이터베이스에 저장한다.
```java
@Target({ElementType.METHOD, ElementType.FIELD})  
@Retention(RetentionPolicy.RUNTIME)  
public @interface Enumerated {  
    EnumType value() default EnumType.ORDINAL;  
}
```
기본값은 `ORDINAL` 이다.
하지만 0, 1과 같이 저장되기 때문에 enum의 값이 추가되거나 변경될 경우 순서가 꼬이기 쉽기 때문에 사용하지 않고, `STRING`을 사용한다.
### 4️⃣ `@Lob`
큰 데이터를 저장하기 위해 BLOB, CLOB을 매핑한다.
CLOB은 문자 타입을 매핑하며 주로 `String`, `char[]`를 매핑할 때 사용한다.
BLOB은 CLOB을 사용하지 않는 나머지의 경우 사용하지만 주로 `byte[]`와 같이 바이트 타입을 매핑할 때 사용한다.
### 5️⃣ `@Transient`
특정 필드를 컬럼에 매핑하지 않고 무시한다.
```java
@Entity  
public class Member {  
  
    @Id  
    private Long id;  
  
    @Column(name = "name")  
    private String username;  
   
    @Transient  
    private int temp;
}
```
이 경우 생성되는 DDL은 아래와 같다.
```sql
create table Member (
	id bigint not null,
	name varchar(255),
	primary key (id)
)
```
## 3. 기본 키 매핑
기본 키는 null이 아니며, 유일해야 하고, 변해서는 안 된다.
미래까지 이 조건을 만족하는 자연 키는 찾기 어려우므로 대리 키를 사용하는 것이 좋다.

> 주민등록번호는 만족할 수 있는 자연키가 되지 않을까?
> 꼭 그렇다고는 할 수 없다. 
> 정부에서 주민등록번호를 저장하지 말라는 규법이 생길 수도 있으며, 주민등록번호를 여러 테이블에서 FK로 가지고 있는 것도 개인정보 탈취의 위험에 처하기 쉽다.

즉, Long 형을 가진 키 생성 전략을 사용하는 대체키를 PK로 매핑하는 것이 권장된다.
### 1️⃣ `@Id`
직접 할당 할 경우 `@Id`만 사용한다.
### 2️⃣ `@GeneratedValue`
자동 생성할 경우 사용한다.

```java
public enum GenerationType {  
    TABLE,  
    SEQUENCE,  
    IDENTITY,  
    UUID,  
    AUTO;  
  
    private GenerationType() {  
    }  
}
```
#### 1) IDENTITY
기본 키 생성을 데이터베이스에 위임한다.

IDENTITY 전략은 데이터베이스에 INSERT SQL을 실행할 때만 PK 값을 알 수 있게 된다.
JPA는 1차 캐시에 엔티티를 저장하여 영속화를 하고 트랜잭션 커밋 시점에 INSERT SQL을 수행하는데,  IDENTITY 전략의 경우 ID를 INSERT SQL 실행 전까지 알 수 없기에 영속성 컨텍스트에 저장하기 어렵다.
그래서 IDENTITY 전략만 예외적으로 `em.persist()` 시점에 즉시 INSERT SQL을 실행하고 DB에서 식별자를 조회한다.
#### 2) SEQUENCE
유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트이다.

```java
@Entity
@SequenceGenerator(
	name = "MEMBER_SEQ_GENERATOR",
	sequenceName = "MEMBER_SEQ",
	initialValue = 1, allocationSize = 1)
)
public class Member {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE,
			generator = "MEMBER_SEQ_GENERATOR")
	private Long id;
}
```
`@SequenceGenerator`를 이용하면 hibernate가 자동으로 생성하는 시퀀스가 아닌 커스텀 시퀀스를 사용할 수 있다.

`allocationSize` 옵션은 시퀀스 한 번 호출에 증가하는 수이다. 기본값은 50이다.
한 트랜잭션 내에서 여러 엔티티를 저장할 때 매번 `call next value`를 하지 않고, 50개의 값을 메모리에 미리 올려 사용하여 성능을 최적화한다.
서버가 여러 대라고 하더라도 DB에는 이미 next value가 
#### 3) TABLE
키 생성 전용 테이블을 만들어 데이터베이스 시퀀스를 흉내내는 전략이다.
모든 데이터베이스에 적용이 가능하지만 테이블을 직접 사용하기 때문에 성능 이슈가 있을 수 있다.

```java
@Entity  
@TableGenerator(  
       name = "MEMBER_SEQ_GENERATOR",  
       table = "MY_SEQUENCES",  
       pkColumnValue = "MEMBER_SEQ", allocationSize = 1  
)  
public class Member {  
  
    @Id  
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "MEMBER_SEQ_GENERATOR")  
    private Long id;
}
```
```sql
create table MY_SEQUENCES (
	next_val bigint,
	sequence_name varchar(255) not null,
	primary key (sequence_name)
)
```
키 생성 전용 테이블이 자동으로 만들어진다.
![](https://i.imgur.com/ypRz6CL.png)
키 생성 전용 테이블에는 sequence의 이름과 다음 키 값이 저장된다.

`allocationSize` 옵션은 시퀀스 전략과 동일하다.