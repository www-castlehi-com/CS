## 1. 정의
엔티티를 영구 저장하는 환경이다.
논리적인 개념이다.
`EntityManager.persist(entity)`를 통해 영속성 컨텍스트에 저장한다.
### 엔티티 매니저란?
![](https://i.imgur.com/Or4EaWm.png)
엔티티를 저장하고, 수정하고, 삭제하고, 조회하는 등 엔티티와 관련된 일을 처리한다.
엔티티 매니저 팩토리를 통해 만들어진다.

엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하여 서로 다른 스레드 간에 공유가 가능하다.
하지만 엔티티 매니저는 스레드 간 절대 공유해서는 안된다.
엔티티 매니저는 엔티티를 관리하는 과정에서 트랜잭션을 시작하며 DB의 커넥션을 얻기 때문에 여러 스레드가 동시에 접근하면 동시성 문제가 발생한다.

```java
<persistence-unit name="hello">  
    <properties>  
        <!-- 필수 속성 -->  
        <property name="jakarta.persistence.jdbc.driver" value="org.h2.Driver"/>  
        <property name="jakarta.persistence.jdbc.user" value="sa"/>  
        <property name="jakarta.persistence.jdbc.password" value=""/>  
        <property name="jakarta.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/Study/Programming/h2/test"/>  
        <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/>  
  
        <!-- 옵션 -->  
        <property name="hibernate.show_sql" value="true"/>  
        <property name="hibernate.format_sql" value="true"/>  
        <property name="hibernate.use_sql_comments"  value="true"/>  
        <property name="hibernate.hbm2ddl.auto" value="update" />  
    </properties>  
</persistence-unit>
```
J2SE 환경에서는 엔티티 매니저 팩토리를 생성할 때 커넥션 풀을 만든다.
그리고 엔티티 매니저는 영속성 컨텍스트와 1:1 매핑을 맺게 된다.

## 2. 엔티티 생명주기
![](https://i.imgur.com/qgtZCHs.png)
### 1️⃣ 비영속
```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");
```
영속성 컨텍스트에 저장되지 않은 객체만 생성된 상태이다.
### 2️⃣ 영속
```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

em.persist(member);
```
생성한 객체를 `em.persist()`로 영속성 컨텍스트에 저장한 상태이다.
영속화했다는 것이 DB에 저장되었다는 것을 의미하지 않는다.
실제로 `em.persist()`시 Insert 쿼리가 발생하지 않는다.
Insert 쿼리는 트랜잭션이 커밋되었을 때 발생한다.

1차 캐시에 저장이 되면 영속 상태라고 할 수 있다.
즉, `em.persist()`로 1차 캐시에 저장한 경우뿐만 아니라 `em.find()`로 1차 캐시 적중이 되지 않아 DB에서 가져와 1차 캐시에 올렸을 때도 영속 상태가 되었다고 할 수 있다.
### 3️⃣ 준영속, 삭제
```java
// 준영속
em.detach(member);

// 삭제
em.remove(member);
```
준영속은 객체가 영속성 컨텍스트에서 지워진 상태이다.

삭제는 영구 저장된 값을 데이터베이스에서 지우는 상태이다.

## 3. 장점
영속성 컨텍스트는 어플리케이션과 데이터베이스 사이의 중간 계층 역할을 한다.
이로써 오는 장점들이 있다.

### 1) 1차 캐시
![](https://i.imgur.com/whsHL3z.png)
영속 상태가 된 엔티티는 영속성 컨텍스트의 id를 key, entity를 value로 한 1차 캐시에 저장된다.
이 때 영속성 컨텍스트를 통해 엔티티를 조회할 경우 DB를 바로 조회하지 않고 영속성 컨텍스트의 1차 캐시에서 조회하게 된다.

만약 1차 캐시에 적중되면 DB를 조회하지 않고도 엔티티를 가져올 수 있게 된다.
1차 캐시에 적중되지 않는다면, DB를 조회하여 그 값을 1차 캐시에 저장하고 반환한다.

큰 이점이 있는 것은 아니다.
왜냐하면 트랜잭션 단위로 동작을 하기 때문에 트랜잭션이 끝나면 1차 캐시도 비워지게 된다.
하나의 트랜잭션 단위 안에서 비즈니스 로직이 복잡한 경우 찰나의 이점을 얻을 수 있다.
### 2) 동일성 보장
```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.println(a == b); // true
```
영속 엔티티의 참조값이 같음을 보장한다.
1차 캐시에서 동일한 객체를 가져오기 때문에 가능하다.

### 3) 트랜잭션을 지원하는 쓰기 지연
![](https://i.imgur.com/9fJPy2Q.png)
엔티티의 상태 중 영속화 상태에서 알아봤듯이 `em.persist()` 시 Insert SQL이 발생하지 않고, 트랜잭션을 커밋하는 순간 발생한다.
`em.persist()`가 발생하면 Insert SQL을 만들어 쓰기 지연 SQL 저장소에 저장해두고, 트랜잭션을 커밋할 때 쓰기 지연 SQL 저장소의 내용이 flush가 되어 DB에 commit 된다.

이를 버퍼링 기능이라고 한다.
hibernate는 `hibernate.jdbc.batch_size` 옵션을 통해 버퍼링 사이즈를 지정할 수 있다.
### 4) 변경 감지
```java
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();
transaction.begin();

Member memberA = em.find(Member.class, "memberA");
memberA.setUsername("hi");
memberA.setAge(10);

transaction.commit();
```
영속화한 엔티티를 수정했을 때 `em.persist()`를 하지 않아도 트랜잭션이 종료되면 update 쿼리가 발생해 DB에도 반영된다.
![](https://i.imgur.com/7ZFPcJw.png)
JPA는 commit을 할 시 내부적으로 `flush()`가 호출된다.
> **Flush()란?**
> : 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 작업이다.
> 1차 캐시가 지워지지 않고 쓰기 지연 SQL 저장소에 있는 쿼리들이 데이터베이스에 반영만 된다.
> 데이터베이스 트랜잭션이 커밋되는 것은 아니다. 커밋을 호출한 경우에만 데이터베이스 트랜잭션이 커밋된다.
> `em.flush()`를 직접 호출할 경우 플러시가 되고, 트랜잭션이 커밋되거나 JPQL 쿼리가 실행될 경우 플러시가 자동 호출된다.

이 때 엔티티와 스냅샷을 비교한다. 스냅샷은 값을 읽어왔을 때 최초의 시점을 저장한다.
즉, 엔티티의 내용이 DB에서 가져온 최초의 값(스냅샷)에서 변경되었다는 것을 감지할 수 있게 된다.

`em.remove()`를 이용하는 삭제 또한 위와 같은 원리로 delete 쿼리가 발생하게 된다.
### 5) 지연 로딩
```java
Member member = em.find(Member.class, 1L);
Team team = member.getTeam();

team.getName();
```
위의 상황에서 `member.getTeam()`으로 얻는 `Team` 엔티티는 실제 엔티티가 아닌 프록시 객체이다.
`team.getName()`을 할 경우 실제 조회 쿼리가 발생하게 되는데 이 때, JPA는 영속성 컨텍스트에 실제 Team 엔티티를 요청하게 된다.
영속성 컨텍스트는 DB에서 해당 데이터를 조회하여 엔티티를 반환해 프록시를 실제 엔티티로 초기화한다.