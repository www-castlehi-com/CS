# 전파(propagation)란
- 트랜잭션이 이미 진행중인데, 추가로 트랜잭션을 수행할 경우 어떻게 동작할지 결정하는 것
# 원칙
## 물리, 논리 트랜잭션
![](https://i.imgur.com/TF1LdDP.png)
- 물리 트랜잭션
	- 실제 데이터베이스에 적용되는 트랜잭션
	- 실제 커넥션을 통해서 트랜잭션을 시작 (`setAutoCommit(false)`)하고, 실제 커넥션을 통해 커밋, 롤백하는 단위
- 논리 트랜잭션
	- 트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위
	- 외부 트랜잭션에 참여하여 하나의 물리 트랜잭션으로 묶임 (`isNewTransaction = false`)
	- 트랜잭션이 진행되는 중에 내부에 추가로 트랜잭션을 사용하는 경우에 발생 (`REQUIRED`전파 옵션 사용 시 발생)
### 1️⃣ 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다
![](https://i.imgur.com/uYNySTJ.png)
##### 로그
```shell
외부 트랜잭션 시작
Creating new transaction with name [null]:
PROPAGATION_REQUIRED,ISOLATION_DEFAULT
Acquired Connection [HikariProxyConnection@1943867171 wrapping conn0] for JDBC transaction
Switching JDBC Connection [HikariProxyConnection@1943867171 wrapping conn0] to manual commit
outer.isNewTransaction()=true

내부 트랜잭션 시작
Participating in existing transaction
inner.isNewTransaction()=false
내부 트랜잭션 커밋

외부 트랜잭션 커밋
Initiating transaction commit
Committing JDBC transaction on Connection [HikariProxyConnection@1943867171 wrapping conn0]
```
- 내부 트랜잭션 시작 시 `Participating in existing transaction` -> 기존 존재하는 외부 트랜잭션에 참여
- 처음 트랜잭션을 시작한 외부 트랜잭션만 물리 트랜잭션을 시작하고 커밋하여 관리하도록 함
##### 과정
![](https://i.imgur.com/7jSqtqH.png)
![](https://i.imgur.com/WqHJ9dk.png)
### 2️⃣ 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다
![](https://i.imgur.com/JZxZKWj.png)
#### 외부 롤백
##### 로그
```shell
외부 트랜잭션 시작
Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
Acquired Connection [HikariProxyConnection@461376017 wrapping conn0] for JDBC transaction
Switching JDBC Connection [HikariProxyConnection@461376017 wrapping conn0] to manual commit

내부 트랜잭션 시작
Participating in existing transaction
내부 트랜잭션 커밋

외부 트랜잭션 롤백
Initiating transaction rollback
Rolling back JDBC transaction on Connection [HikariProxyConnection@461376017 wrapping conn0]
Releasing JDBC Connection [HikariProxyConnection@461376017 wrapping conn0] after transaction
```
- 내부 트랜잭션은 물리 트랜잭션에 직접 관여 X
- 외부 트랜잭션이 물리 트랜잭션을 시작하고 롤백
- 외부 트랜잭션에서 시작한 물리 트랜잭션의 범위가 내부 트랜잭션까지 사용되어 전체 내용 모두 롤백
##### 과정
![](https://i.imgur.com/fyaNQ48.png)
#### 내부 롤백
##### 로그
```shell
외부 트랜잭션 시작
Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
Acquired Connection [HikariProxyConnection@220038608 wrapping conn0] for JDBC transaction
Switching JDBC Connection [HikariProxyConnection@220038608 wrapping conn0] to manual commit

내부 트랜잭션 시작
Participating in existing transaction
내부 트랜잭션 롤백
Participating transaction failed - marking existing transaction as rollback-only
Setting JDBC transaction [HikariProxyConnection@220038608 wrapping conn0] rollback-only

외부 트랜잭션 커밋
Global transaction is marked as rollback-only but transactional code requested
Initiating transaction rollback
Rolling back JDBC transaction on Connection [HikariProxyConnection@220038608 wrapping conn0]
Releasing JDBC Connection [HikariProxyConnection@220038608 wrapping conn0] after transaction
```
- 내부 트랜잭션 롤백 시 `Participating transaction failed - marking existing transaction as rollback-only` -> 실제 물리 트랜잭션은 롤백하지 않고 기존 트랜잭션을 롤백 전용으로 표시
- 외부 트랜잭션 커밋 시 `Global transaction is marked as rollback-only` -> 트랜잭션이 롤백 전용이므로 물리 트랜잭션 롤백
##### 과정
![](https://i.imgur.com/z5QyWt1.png)
- 내부 트랜잭션이 롤백 되었는데, 외부 트랜잭션(`rollbackOnly`)이 커밋되면 `UnexpectedRollbackException` 예외 발생
# 전파 속성
## 1️⃣ REQUIRED
### 개요
- 기본값
- 기존 트랜잭션이 없으면 생성하고, 있으면 참여
![](https://i.imgur.com/Itz9PPB.png)
- 같은 동기화 커넥션 사용
## 2️⃣ REQUIRES_NEW
### 개요
-  항상 새로운 트랜잭션 생성
- 외부 트랜잭션과 내부 트랜잭션을 분리해서 사용하는 방법
- 각각 별도의 물리 트랜잭션을 사용하므로 커밋과 롤백도 각각 별도로 이루어짐
- 내부 트랜잭션 시작 시 기존 트랜잭션에 참여하는 것이 아니라 새로운 트랜잭션 시작
### 사용법
![](https://i.imgur.com/rF2t1F5.png)
#### 로그
```shell
외부 트랜잭션 시작
Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
Acquired Connection [HikariProxyConnection@1064414847 wrapping conn0] for JDBC transaction
Switching JDBC Connection [HikariProxyConnection@1064414847 wrapping conn0] to manual commit
outer.isNewTransaction()=true

내부 트랜잭션 시작
Suspending current transaction, creating new transaction with name [null]
Acquired Connection [HikariProxyConnection@778350106 wrapping conn1] for JDBC transaction
Switching JDBC Connection [HikariProxyConnection@778350106 wrapping conn1] to manual commit
inner.isNewTransaction()=true

내부 트랜잭션 롤백
Initiating transaction rollback
Rolling back JDBC transaction on Connection [HikariProxyConnection@778350106 wrapping conn1]
Releasing JDBC Connection [HikariProxyConnection@778350106 wrapping conn1] after transaction
Resuming suspended transaction after completion of inner transaction

외부 트랜잭션 커밋
Initiating transaction commit
Committing JDBC transaction on Connection [HikariProxyConnection@1064414847 wrapping conn0]
Releasing JDBC Connection [HikariProxyConnection@1064414847 wrapping conn0] after transaction
```
#### 과정
##### 내부 커밋
![](https://i.imgur.com/6kVE0iA.png)
##### 내부 롤백
![](https://i.imgur.com/YhnPCtH.png)
### 3️⃣ SUPPORT
- 기존 트랜잭션이 없으면 없는대로 진행하고, 있으면 참여
### 4️⃣ NOT_SUPPORT
- 기존 트랜잭션이 없으면 없는대로 진행하고, 있으면 트랜잭션 없이 진행 (기존 트랜잭션 보류)
### 5️⃣ MANDATORY
- 기존 트랜잭션이 없으면 `IllegalTransactionStateException` 발생, 있으면 참여
### 6️⃣ NEVER
- 기존 트랜잭션이 없으면 없이 진행하고, 있으면 `IllegalTransactionStateException` 발생
### 7️⃣ NESTED
- 기존 트랜잭션이 없으면 새로 생성하고, 있으면 중첩 트랜잭션 생성
- 중첩 트랜잭션은 외부 트랜잭션의 영향을 받지만, 외부에 영향을 주지 않는다
	- 롤백 되어도 외부 트랜잭션은 커밋 가능
	- 외부 트랜잭션이 롤백 되면 중첩 트랜잭션도 함께 롤백
> JDBC savepoint 기능 사용
> JPA에서는 사용 불가
# 옵션
- `isolation`, `timeout`, `readOnly`는 트랜잭션이 처음 시작될 때만 적용되며 참여 시에는 미적용
	- `REQUIRED`, `REQUIRES_NEW`를 통한 시작 시점에만 적용