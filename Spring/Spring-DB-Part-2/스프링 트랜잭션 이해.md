# 트랜잭션 적용 확인
## 트랜잭션 프록시 등록
![](https://i.imgur.com/1lzzBqv.png)
- `@Transactional` 애노테이션이 특정 클래스나 메서드에 하나라도 있으면 트랜잭션 AOP는 프록시를 만들어서 스프링 컨테이너에 등록
- `service$$CGLIB`를 스프링 빈에 등록
> 다형성 활용

![](https://i.imgur.com/RrmgrSs.png)
- 프록시는 내부에 실제 `service` 참조
- 메서드 호출 시 프록시는 메서드가 트랜잭션을 사용할 수 있는지 확인 후 적용 대상일 경우 트랜잭션 시작 후 실제 메서드 호출
- 호출이 끝나서 프록시로 제어가 돌아오면 프록시는 트랜잭션 로직을 커밋하거나 롤백해서 트랜잭션 종료
## 적용 여부
`TransactionSynchronizationManager.isActualTransactionActive()`
- 현재 쓰레드에 트랜잭션이 적용되어 있는지 확인
- `true` : 트랜잭션 적용
- `false` : 트랜잭션 미적용
`TransactionSynchronizationManager.isCurrentTransactionReadOnly()`
- 현재 트랜잭션에 적용된 `readOnly` 옵션의 값 확인
- `@Transactional` == `@Transactional(readOnly=false)`
# 스프링 `@Transactional` 규칙
## 규칙
### 1️⃣ 우선순위
- **더 구체적이고 자세한 것**이 높은 우선순위
	- 클래스보다는 메서드 옵션이 적용
### 2️⃣ 클래스에 적용하면 메서드 자동 적용
- 트랜잭션이 없을 경우 더 상위인 클래스 확인
## 인터페이스 적용
### 우선순위
1. 클래스의 메서드
2. 클래스의 타입
3. 인터페이스의 메서드
4. 인터페이스의 타입
### 주의
- 인터페이스에 사용하는 것은 권장하지 않는 방법
- AOP를 적용하는 방식에 따라 인터페이스에 애노테이션은 AOP 적용이 되지 않을 수 있음

> 과거에는 구체 클래스를 기반으로 프록시를 생성하는 CGLIB 방식 사용 시 인터페이스의 애노테이션을 인식하지 못했지만 스프링 5.0에서 개선
# 주의 사항
## 프록시 내부 호출
### 배경
- 트랜잭션 AOP는 프록시 객체가 요청을 먼저 받아서 트랜잭션을 처리하고, 실제 객체를 호출
	- 프록시를 스프링 빈으로 등록함
	- 의존관계 주입 시에 항상 실제 객체 대신 프록시 객체가 주입됨
- 프록시에서 먼저 트랜잭션을 적용하고, 이후에 대상 객체를 호출하게 됨
### 문제 상황
- 프록시를 거치지 않고 대상 객체를 직접 호출하게 되면 AOP가 적용되지 않고 트랜잭션도 적용되지 않음
### 발생 이유
- 대상 객체의 내부에서 메서드 호출이 발생하면 프록시를 거치지 않고 대상 객체를 직접 호출하게 됨
- 이 경우 `@Transactional`이 있어도 트랜잭션이 적용되지 않음
### 과정
#### 직접 호출
![](https://i.imgur.com/kgv1jGQ.png)
1. `callService`의 `internal()` 호출
2. `callService`의 트랜잭션 프록시가 호출됨
3. `internal()` 메서드에 `@Transactional`이 붙어 있으므로 트랜잭션 프록시는 트랜잭션을 적용
4. 트랜잭션 적용 후 실제 `callService` 객체 인스턴스의 `internal()` 호출
#### 내부 호출
![](https://i.imgur.com/XP3vjwk.png)
1. `callService`의 `external()` 호출
2. `callService`의 트랜잭션 프록시가 호출됨
3. `external()` 메서드에는 `@Trnasactional`이 없으므로 트랜잭션을 적용하지 않음
4. 트랜잭션을 적용하지 않고 `callService` 객체 인스턴스의 `external()` 호출
5. `external()` 내부에서 `internal()` 메서드를 호출
	- 실제 자기 자신 (`this`), 즉 대상 객체 (`target`)의 인스턴스를 호출하므로 프록시를 거치지 않아 트랜잭션을 적용할 수 없게됨
### 해결 방법
![](https://i.imgur.com/QAnxPJj.png)
1. `callService`의 `external()` 호출
2. `callService`는 실제 `callService` 객체 인스턴스
3. `callService`는 주입 받은 `internalService.internal()` 호출
4. `internalService`는 트랜잭션 프록시이며 `@Transactional`에 따라 트랜잭션 적용
5. 트랜잭션 적용 후 실제 `intenralService` 객체 인스턴스의 `internal()` 호출
## public 메서드만 적용
```java
@Transactional
public class Hello {
	public method1();
	method2();
	protected method3();
	private method4();
}
```
- 트랜잭션이 의도하지 않은 곳까지 트랜잭션이 과도하게 적용될 수 있음

> 스프링 부트 3.0 이후부터는`protected`, `package-visiable`(default)에도 트랜잭션 적용
# 초기화 시점
### 이유
- 초기화 코드가 먼저 호출되고 트랜잭션 AOP가 적용
	- `@PostConstruct`와 `@Transactional`을 함께 사용할 경우 트랜잭션이 적용되지 않는다
### 해결 방법
- 이벤트 메서드는 트랜잭션 AOP를 포함한 스프링 컨테이너가 완전히 생성되고 난 후에 호출
	- `ApplicationReadyEvent` 이벤트 사용
# 트랜잭션 옵션
## `@Transactional`
```java
@Target({ElementType.TYPE, ElementType.METHOD})  
@Retention(RetentionPolicy.RUNTIME)  
@Inherited  
@Documented  
@Reflective  
public @interface Transactional {  
    @AliasFor("transactionManager")  
    String value() default "";  
  
    @AliasFor("value")  
    String transactionManager() default "";  
  
    String[] label() default {};  
  
    Propagation propagation() default Propagation.REQUIRED;  
  
    Isolation isolation() default Isolation.DEFAULT;  
  
    int timeout() default -1;  
  
    String timeoutString() default "";  
  
    boolean readOnly() default false;  
  
    Class<? extends Throwable>[] rollbackFor() default {};  
  
    String[] rollbackForClassName() default {};  
  
    Class<? extends Throwable>[] noRollbackFor() default {};  
  
    String[] noRollbackForClassName() default {};  
}
```
### value, transactionmanager
- 트랜잭션을 사용하려면 스프링 빈에 등록된 어떤 트랜잭션 매니저를 사용할지 알아야 함
- 사용할 트랜잭션 매니저를 지정할 때 `value`, `transactionManager` 둘 중 하나에 트랜잭션 매니저의 스프링 빈의 이름을 기입
- 생략 시 기본으로 등록된 트랜잭션 매니저 사용
### rollbackFor
- 특정 예외가 발생할 때 롤백할지 지정 가능
### noRollbackFor
- 특정 예외가 발생했을 때 롤백하면 안되는지 지정 가능
### isolation
- 격리 수준 지정
- 기본값 : `DEFAULT`
- 대부분 데이터베이스에서 설정한 기준을 따름
### timeout
- 트랜잭션 수행 시간에 대한 타임아웃 (초)
- 기본 값 : 트랜잭션 시스템의 타임아웃
### label
- 트랜잭션 애노테이션에 있는 값을 직접 읽어서 어떤 동작을 하고 싶을 때 사용
### readOnly
- 기본적으로 읽기 쓰기가 모두 가능한 트랜잭션이 생성되지만, 읽기 전용 트랜잭션이 생성됨
- 등록, 수정, 삭제가 되지 않고 읽기만 가능함
- 읽기에서 다양한 성능 최적화가 발생할 수 있음
#### 적용
1. **프레임워크**
	- JdbcTemplate은 읽기 전용 트랜잭션 안에서 변경 기능을 실행하면 예외
	- JPA는 읽기 전용 트랜잭션의 경우 커밋 시점에 플러시를 호출하지 않음
2. **JDBC 드라이버**
	- 읽기 전용 트랜잭션에서 변경 쿼리가 발생하면 예외
	- 읽기, 쓰기 데이터베이스를 구분해서 요청
3. **데이터베이스**
	- 읽기 전용 트랜잭션의 경우 읽기만 하면 되므로 성능 최적화
# 예외 발생
## 기본 정책
![](https://i.imgur.com/jzpoglF.png)
- 언체크 예외 : `RuntimeException`, `Error` 및 하위 => 트랜잭션 롤백
- 체크 예외 : `Exception` 및 하위 => 트랜잭션 커밋
## 활용
### 비즈니스 예외
- 시스템에 문제가 있어서 발생한 예외가 아닌, 정상 동작했지만 비즈니스 상황에서 문제가 되는 예외
	> ex) 주문시 결제 잔고 부족하면 주문 데이터를 저장하고, 결제 상태를 `대기`로 처리
