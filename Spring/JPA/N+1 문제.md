## 1. 정의
어떤 엔티티 컬렉션을 조회할 때, 부모 엔티티를 가져오는 1개의 쿼리 뒤에, 각 부모 엔티티의 연관 컬렉션을 초기화하기 위해 추가로 N개의 SELECT 쿼리가 실행되는 문제다.

N+1문제를 설명하기 위해 가져온 예시는 Applicatoin-ServiceGroup-Service 구조이다.
```java
public class Application {  
  
    @Id  
    @GeneratedValue    
    private Long id;  
  
    private String name;  
  
    @OneToMany(mappedBy = "application", cascade = CascadeType.ALL)  
    private List<ServiceGroup> serviceGroups = new ArrayList<>();
}

public class ServiceGroup {  
  
    @Id  
    @GeneratedValue    
    private Long id;  
  
    private String name;  
  
    @ManyToOne
    private Application application;  
  
    @OneToMany(mappedBy = "serviceGroup", cascade = CascadeType.ALL)  
    private List<Service> services = new ArrayList<>();   
}

public class Service {  
  
    @Id  
    @GeneratedValue    
    private Long id;  
  
    private String name;  
  
    @Setter  
    @ManyToOne
    private ServiceGroup serviceGroup;  
}
```
Application : ServiceGroup : Service = 1 : m : n 구조이다.
## 2. FetchType
FetchType은 엔티티 간의 연관 관계 데이터를 언제, 어떻게 데이터베이스에서 가져올지 결정하는 설정을 의미한다.

FetchType에는 EAGER와 LAZY가 있다.
EAGER은 즉시 로딩으로 엔티티를 조회할 때 연관된 엔티티도 즉시 함께 데이터베이스에서 가져온다.
LAZY는 지연 로딩으로 연관된 엔티티를 당장 가져오지 않고, 실제 해당 연관 엔티티의 데이터에 접근할 때 데이터베이스에서 조회한다.

타입 이름에서 유추할 수 있듯이
>"지연 로딩은 내가 원할 때 데이터베이스에서 조회하니까 추가적인 SQL이 발생하겠구나!
즉시 로딩은 처음에 다 초기화를 하니까 추가적인 SQL이 발생하지 않겠구나!"

라고 생각할 수 있다.

```java
public List<String> getServiceNames(Long serviceGroupId) {  
    ServiceGroup serviceGroup = serviceGroupRepository.findById(serviceGroupId)  
          .orElseThrow(() -> new IllegalArgumentException(serviceGroupId + "isn't valid"));  
  
    return serviceGroup.getServices().stream()  
          .map(hello.jpatest.nplus1.domain.Service::getName)  
          .collect(Collectors.toList());  
}
```
serviceGroup 한 개로부터 n개의 연관된 Service들의 이름을 반환하는 메서드이다.

우선 FetchType이 EAGER일 때를 살펴보자.
```SQL
2025-11-21T22:49:48.263+09:00 DEBUG 38394 --- [jpa-test] [nio-8080-exec-2] org.hibernate.SQL                        : 
    select
        sg1_0.id,
        a1_0.id,
        a1_0.name,
        sg1_0.name,
        s1_0.service_group_id,
        s1_0.id,
        s1_0.name 
    from
        service_group sg1_0 
    left join
        application a1_0 
            on a1_0.id=sg1_0.application_id 
    left join
        service s1_0 
            on sg1_0.id=s1_0.service_group_id 
    where
        sg1_0.id=?
```
serviceGroup을 가져오는데 join 쿼리가 나갔다.
그래서 각각의 service의 name을 가져오는데에도 추가 쿼리가 발생하지 않았다.

다음은 LAZY일 때를 살펴보자.
```SQL
2025-11-21T22:59:37.718+09:00 DEBUG 38581 --- [jpa-test] [nio-8080-exec-2] org.hibernate.SQL                        : 
    select
        sg1_0.id,
        a1_0.id,
        a1_0.name,
        sg1_0.name 
    from
        service_group sg1_0 
    left join
        application a1_0 
            on a1_0.id=sg1_0.application_id 
    where
        sg1_0.id=?
2025-11-21T22:59:37.725+09:00 DEBUG 38581 --- [jpa-test] [nio-8080-exec-2] org.hibernate.SQL                        : 
    select
        s1_0.service_group_id,
        s1_0.id,
        s1_0.name 
    from
        service s1_0 
    where
        s1_0.service_group_id=?
```
이중 구조라 예시가 복잡하지만 serviceGroup을 조회할 때 service와 join하는 SQL문이 발생하지 않았다.
그리고 service의 name을 요청하는 순간 service를 추가 요청하는 SQL문이 발생한다.

---
>그러면 진짜 LAZY에서만 N+1이 발생하는 게 아닐까?
>EAGER를 쓰면 해결되지 않을까?

라고 생각할 수 있다.

아래는 Application을 조회하는 예시이다.
```java
public ApplicationDto getApplication(Long id) {  
    Application application = findApplication(id);  
  
    return modelMapper.map(application, ApplicationDto.class);  
}
```
단순히 application을 조회하기만 한다.

먼저, EAGER 부터 살펴보자.
```SQL
2025-11-21T23:03:09.465+09:00 DEBUG 38649 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        a1_0.id,
        a1_0.name,
        sg1_0.application_id,
        sg1_0.id,
        sg1_0.name 
    from
        application a1_0 
    left join
        service_group sg1_0 
            on a1_0.id=sg1_0.application_id 
    where
        a1_0.id=?
2025-11-21T23:03:09.472+09:00 DEBUG 38649 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        s1_0.service_group_id,
        s1_0.id,
        s1_0.name 
    from
        service s1_0 
    where
        s1_0.service_group_id=?
2025-11-21T23:03:09.473+09:00 DEBUG 38649 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        s1_0.service_group_id,
        s1_0.id,
        s1_0.name 
    from
        service s1_0 
    where
        s1_0.service_group_id=?
```
application과 service group은 join이 됐다.
그런데 service를 로딩해올 때 service group 개수마다 SQL이 발생했다.

다음은 LAZY를 살펴보자.
```SQL
2025-11-21T23:07:24.254+09:00 DEBUG 38748 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        a1_0.id,
        a1_0.name 
    from
        application a1_0 
    where
        a1_0.id=?
```
application을 가져오는 단 하나의 쿼리만 발생했다.
물론 service group이나 service 정보를 조회하게 되면 SQL이 추가로 발생한다.

어쨌든 EAGER, LAZY는 N+1문제에서 벗어날 수 없다.
그저 N+1이 발생하는 **시점**만 차이가 있을 뿐이다.

## 3. 해결해야 하는 이유
N+1을 해결하기 전에... 어차피 가져와야 하면 SQL이 필요하고, SQL 쿼리 실행은 싼 값인데 왜 문제이고 해결해야할까?
### 1️⃣ 쿼리 수의 기하급수적 증가
준비해 온 예시는 데이터의 트리 구조를 잘 나타낸다.
Application에 1개의 데이터, 동일 applicationId에 ServiceGroup에 100개, 그리고 ServiceGroup 각각에 1000개의 Service가 있다고 가정해보자.
Full Load를 한다고 했을 경우, 쿼리는 $1 * 100 * 1000 = 100,000$ 개가 발생한다.

그리고 사용자 10명이 동시에 접속한다고 가정하자.
SQL은 동시에 100만개가 실행되어야 한다.
### 2️⃣ DB 부하 증가
단순히 쿼리의 수에만 영향이 미치는 것이 아니다.
쿼리가 발생하려면 DB에 connection을 맺어야 한다.

우리의 시스템은 100만 개의 ConnectionPool을 갖고 있지 않을 것이다.
그러면 요청은 앞선 요청의 처리를 기다려야 한다.
10코어 CPU라면 10만 번의 연산을 기다려야 한다. 물론, CPU가 DB I/O만 하겠다라는 전제 하다.
결국 서버 전체가 느려지는 결과를 낳을 것이다.
### 3️⃣ DB Round-Trip 비용
생각보다 CPU의 처리량은 어마어마하다. 그래서 10만 번의 연산이더라도 우리의 생각보다는 금방 할 수 있다.
하지만, 연산을 하기 위한 시간에는 네트워크 대기 시간 포함된다.
DB와 애플리케이션 서버 사이 왕복 네트워크 비용이 추가되어야 하는 것이다.
DB는 빠를지 몰라도 네트워크는 절대 빠르지 않다.
## 4. 해결 방법
자, 우리는 FetchType으로는 N+1문제를 전혀 해결할 수 없다는 걸 알게됐다.
그리고 시스템적인 부하 문제가 있기에 해결해야함을 깨달았다.

그러면 N+1 문제는 어떻게 해결할 수 있을까?

### 1️⃣ FetchType.LAZY + FetchJoin
FetchJoin은 Entity에 대해 조회할 때 LazyLoading으로 설정되어있는 연관관계를 Join 쿼리를 발생시켜 한 번에 조회할 수 있는 기능이다.
Join은 조회의 주체가 되는 Entity만 영속화하는 반면에 FetchJoin은 해당되는 모든 Entity를 영속화한다.

이 방법은 조회 시점에 FetchJoin으로 조회한 Entity는 모두 영속성 컨텍스트에 들어있다는 점을 이용한다.

앞선 예시인 service group을 통해 servic들의 이름을 반환하는 메서드를 통해 확인해보자.

```java
@Query("select distinct sg from ServiceGroup sg join fetch sg.services where sg.id = :id")  
Optional<ServiceGroup> findByIdWithFetchJoin(@Param("id") Long id);
```
JPQL을 통해 fetch join을 명시했다.

```SQL
2025-11-21T23:41:56.663+09:00 DEBUG 39298 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        distinct sg1_0.id,
        sg1_0.application_id,
        sg1_0.name,
        s1_0.service_group_id,
        s1_0.id,
        s1_0.name 
    from
        service_group sg1_0 
    join
        service s1_0 
            on sg1_0.id=s1_0.service_group_id 
    where
        sg1_0.id=?
```
service group 조회부터 각 service의 이름을 가져오는 것까지 단 한 번의 SQL이 발생했다.

SQL이 단 한번이기에 효율성이 높고, 단방향 & 양방향이 모두 가능하다.

하지만 여러 단점이 있다.
#### 1) 다중 FetchJoin 불가

```java
@Query("select a from Application a join fetch a.serviceGroups sg join fetch sg.services where a.id = :id") 
Optional<Application> findByIdWithFetchJoin(@Param("id") Long id);
```
우리가 보고 있는 예시는 트리 구조이다. 그래서 application 조회 시 serviceGroup에 이어 service까지 fetch join을 해 본다.

![](https://i.imgur.com/rq7zLUn.png)
결과는 완전히 실패다.

Hibernate는 내부 컬렉션 초기화 시 한 번의 흐름(stream)으로만 초기화 해야한다.
한 번 이상의 stream을 거칠 경우 복원이 불가능해지기 때문이다.

application을 조회할 때 fetch join을 두 번 사용하면 두 컬렉션에 대해서 동시에 초기화를 해 주어야 하는데, service group을 초기화하고 있을 때 같은 스트림에서 service 초기화가 불가능하다.
따라서 Hibernate는 다중 FetchJoin을 지원하지 않고 있다.

#### 2) 페이징 불가
페이징은 DB row 기준이며, 부모 기준이 아니다.
하지만 fetch join은 row 폭발을 만든다.

service group이 1개이고 이 내부의 service가 5개 있을 때 fetch join은 아래의 결과를 만든다.

| sg_id | sg_name | svc_id | svc_name |
| ----- | ------- | ------ | -------- |
| 1     | A       | 1      | S1       |
| 1     | A       | 2      | S2       |
| 1     | A       | 3      | S3       |
| 1     | A       | 4      | S4       |
| 1     | A       | 5      | S5       |

여기에 limit과 offset을 걸 경우 결과는 아래와 같다.

|sg_id|svc_id|
|---|---|
|1|1|
|1|2|
service를 5개를 갖는 service group이 갑자기 service를 2개만 갖는 객체가 되었다.

데이터가 일치하지 않는 모순이 발생하기에 Hibernate는 FetchJoin시 페이징을 지원하지 않는다.

다만, 실제로 실행해보면 다중 fetch join처럼 오류가 발생하지 않고 부모 Entity 기준으로 페이징을 해서 정상인 것처럼 보일 것이다.
이는 Hibernate가 메모리 페이징으로 동작을 변경했기 때문이다.
이 말인 즉슨 메모리에 결과가 모두 올라와야 한다는 것이고 만에 하나 메모리가 부족하다면 OOM이 발생한다는 것이다.

그래서 JPA 스펙에서도 컬렉션 fetch join과 페이징은 사용하지 않도록 권고한다.

### 2️⃣ @BatchSize
FetchJoin은 다중 join을 지원하지 않았고, 페이징이 불가했다.
BatchSize는 이를 해결한다.

application을 조회해오는 예제를 수행해보자.

```java
@BatchSize(size = 10)  
@OneToMany(mappedBy = "application", cascade = CascadeType.ALL, fetch = FetchType.LAZY)  
private List<ServiceGroup> serviceGroups = new ArrayList<>(); 

@BatchSize(size = 3)  
@OneToMany(mappedBy = "serviceGroup", cascade = CascadeType.ALL, fetch = FetchType.LAZY)  
private List<Service> services = new ArrayList<>();
```
application이 1개, service group이 10개, service가 각각 5개 저장되어 있는 상황이다.

service group을 조회해올 때 batchSize는 10, service는 3으로 설정했다.

아래는 application을 조회하여 하위 연관 관계를 모두 로딩했을 때 쿼리 결과다.
```java
2025-11-22T00:53:13.011+09:00 DEBUG 40822 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        a1_0.id,
        a1_0.name 
    from
        application a1_0 
    where
        a1_0.id=?
2025-11-22T00:53:13.031+09:00 DEBUG 40822 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        sg1_0.application_id,
        sg1_0.id,
        sg1_0.name 
    from
        service_group sg1_0 
    where
        sg1_0.application_id=?
2025-11-22T00:53:13.040+09:00 DEBUG 40822 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        s1_0.service_group_id,
        s1_0.id,
        s1_0.name 
    from
        service s1_0 
    where
        s1_0.service_group_id in (?, ?, ?)
2025-11-22T00:53:13.049+09:00 DEBUG 40822 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        s1_0.service_group_id,
        s1_0.id,
        s1_0.name 
    from
        service s1_0 
    where
        s1_0.service_group_id in (?, ?, ?)
2025-11-22T00:53:13.057+09:00 DEBUG 40822 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        s1_0.service_group_id,
        s1_0.id,
        s1_0.name 
    from
        service s1_0 
    where
        s1_0.service_group_id in (?, ?, ?)
2025-11-22T00:53:13.064+09:00 DEBUG 40822 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        s1_0.service_group_id,
        s1_0.id,
        s1_0.name 
    from
        service s1_0 
    where
        s1_0.service_group_id=?
```
application에 대해서 1번, service group에 대해서 1번, service에 대해서 4번의 쿼리가 발생한다.

Hibernate는 Lazy인 컬렉션을 접근할 때 단일 PK가 아니라 batch_size 만큼의 부모 ID를 기준으로 묶어서 조회한다.

```java
ServiceGroup IDs = [1,2,3,4,5,6,7,8,9,10]
batch_size = 3
```
10개의 ServiceGroup의 id는 위와 같을 것이다.
이 상태에서 Service를 꺼내면 Hibernate는 첫 3개 SG ID를 묶어서 한 번에 조회하고, 다음 3개를 또 묶어서 조회할 것이다.
```java
IN (1,2,3)
IN (4,5,6)
IN (7,8,9)
IN (10)
```
결국 위 네 그룹으로 묶여 조회가 된다.

그래서 ServiceGroup을 조회할 땐 Application이 1개이므로 1번 조회가 발생했고,
Service를 조회할 땐 ServiceGroup이 10개이고 BatchSize가 3이므로 4번의 조회가 발생한 것이다.

### 3️⃣ EntityGraph
JPA가 어떤 연관을 함께 로딩할지 코드로 지정한다.
즉, 동적으로 FetchType을 지정하는 것으로 이해하면 된다.

앞선 예제와 마찬가지로 application을 조회하는 메서드를 수행하자.
그리고 BatchSize는 그대로 유지한다.

```java
@EntityGraph(attributePaths = {"serviceGroups"})  
Optional<Application> findById(Long id);
```

```java
2025-11-22T01:19:57.613+09:00 DEBUG 41369 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        a1_0.id,
        a1_0.name,
        sg1_0.application_id,
        sg1_0.id,
        sg1_0.name 
    from
        application a1_0 
    left join
        service_group sg1_0 
            on a1_0.id=sg1_0.application_id 
    where
        a1_0.id=?
2025-11-22T01:19:57.644+09:00 DEBUG 41369 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        s1_0.service_group_id,
        s1_0.id,
        s1_0.name 
    from
        service s1_0 
    where
        s1_0.service_group_id in (?, ?, ?)
2025-11-22T01:19:57.652+09:00 DEBUG 41369 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        s1_0.service_group_id,
        s1_0.id,
        s1_0.name 
    from
        service s1_0 
    where
        s1_0.service_group_id in (?, ?, ?)
2025-11-22T01:19:57.659+09:00 DEBUG 41369 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        s1_0.service_group_id,
        s1_0.id,
        s1_0.name 
    from
        service s1_0 
    where
        s1_0.service_group_id in (?, ?, ?)
2025-11-22T01:19:57.666+09:00 DEBUG 41369 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        s1_0.service_group_id,
        s1_0.id,
        s1_0.name 
    from
        service s1_0 
    where
        s1_0.service_group_id=?

```

application과 serviceGroups 매핑은 LEFT JOIN 을 이용했고, serviceGroup과 services 매핑은 이전 예시에서 사용한 BatchSize를 이용한 것으로 볼 수 있다.
만약 BatchSize가 없다면 N개의 쿼리가 발생한다.

EntityGraph는 상황에 따라 Hibernate가 fetch join 또는 batch loading을 선택한다.
따라서 트리 구조를 위해서는 BatchSize를 항상 함께 쓰는 것이 좋다.

### 4️⃣ DTO Projection
DB에서 필요한 컬럼만 가져오는 것이다.

지금까지 우리는 application 조회 등의 예시로 N+1 문제를 살펴보았다.
이것이 가능했던 이유는 application 조회 메서드에서 반환하는 DTO가 아래와 같은 구조를 가지고 있기 때문이다.
```java
@Data  
public class ApplicationDto {  
  
    private Long id;  
    private String name;  
    private List<ServiceGroupDto> serviceGroups = new ArrayList<>();;  
}
```
조회 메서드에서 매핑을 해서 반환을 하는 과정에 Lazy loading인 serviceGroups를 다 순회하면서 N+1 문제가 발생했다.

그런데 가장 좋은 것은 API에 필요한 정보만 넘기는 것이다.
Application을 조회하는 API는 Application 정보만 반환하면 되며, Service Groups에 대한 정보를 반환할  필요가 없다고 가정해보자.
```java
@Data  
public class ApplicationDto {  
  
    private Long id;  
    private String name;  
}
```
DTO구조는 간단해지며 Application 정보만 받아 사용하는 API에서 불필요한 정보를 더 이상 넘기지 않아도 되게 되었다.

이 경우, Lazy Loading일 시 SQL 쿼리는 어떻게 될까?

```SQL
2025-11-21T23:07:24.254+09:00 DEBUG 38748 --- [jpa-test] [nio-8080-exec-1] org.hibernate.SQL                        : 
    select
        a1_0.id,
        a1_0.name 
    from
        application a1_0 
    where
        a1_0.id=?
```
대상 Entity인 application 조회 SQL만 발생하고 끝난다.

---
지금까지 N+1 문제를 해결하는 방법에 대해서 알아보았다.

단연 DTO Projection이 가장 좋은 방법이다.
다른 방법에 대해서 정리를 해 보자면, FetchJoin은 1:1 매핑에 유리했고 batch_size는 컬렉션 연관관계일 때 유리했다.
그래서 이 두 방법을 모두 포괄하는 EntityGraph가 가장 유리한 선택이다.