# 개요
## 애스펙트
- **관점**이라는 뜻이며, 애플리케이션을 바라보는 관점을 하나하나의 기능에서 횡단 관심사 관점으로 달리 보는 것이다.
- 핵심 기능과 부가 기능을 분리한다.
	- **핵심 기능**
		- 해당 객체가 제공하는 고유의 기능
	- **부가 기능**
		- 핵심 기능을 보조하기 위해 제공되는 기능
		- 하나의 부가 기능이 여러 곳에서 공통으로 사용되므로, **횡단 관심사**(cross-cutting concerns)가 된다.
		> ex) 로그 추적 기능, 트랜잭션 기능
		
		- 기능 적용 문제가 따른다.
			- 반복적
			- 중복 코드 
			- 변경 시 중복 코드로 인해서 많은 수정이 필요
			- 적용 대상을 변경할 때 많은 수정이 필요
- 부가 기능과 해당 부가 기능을 어디에 적용할지 정의한다.
- 스프링이 제공하는 어드바이저도 어드바이스와 포인트컷을 가지고 있으므로 하나의 애스펙트이다.

> 애스펙트를 사용한 프로그래밍 방식을 **관점 지향 프로그래밍 AOP** (Aspect-Oriented Programming)이라고 한다.
> OOP를 대체하기 위한 것이 아닌 횡단 관심사를 깔끔하게 처리하기 어려운 OOP의 부족한 부분을 보완한다.
## AspectJ 프레임워크
- AOP의 대표적인 구현
	- 스프링도 AOP를 지원하지만 대부분 AspectJ의 문법을 차용하고, AspectJ가 제공하는 기능의 일부만 제공한다.
- 자바 프로그래밍 언어에 대한 완벽한 관점 지향 확장
- 횡단 관심사의 깔끔한 모듈화
	- 오류 검사 및 처리
	- 동기화
	- 성능 최적화 (캐싱)
	- 모니터링 및 로깅
# 적용 방식
## 1️⃣ 컴파일 타임
- 위빙(Weaving) : 원본 로직에 부가 기능 로직이 추가되는 것
### 위빙
![](https://i.imgur.com/vrlcMo7.png)
- `.java` 소스 코드를 AspectJ가 제공하는 컴파일러를 사용해서 `.class`를 만드는 시점에 부가 기능 로직 추가
- `.class`를 디컴파일 해보면 애스펙트 관련 호출 코드가 포함된다.
- AspectJ 컴파일러는 Aspect를 확인해서 해당 클래스가 적용 대상인지 먼저 확인하고, 적용 대상인 경우에 부가 기능 로직 적용
### 단점
- 특별한 컴파일러가 필요하며 복잡
## 2️⃣ 로드 타임
### 위빙
![](https://i.imgur.com/Ym9Q1l8.png)
- 자바를 실행하면 자바 언어는 `.class` 파일을 JVM 내부의 클래스 로더에 보관하는데, 중간에서 `.class` 파일을 조작한 다음 JVM에 올릴 수 있다.
	- Java Instrumentation 참고. 보통 모니터링 툴에서 사용
### 단점
- 자바를 실행할 때 특별한 옵션 (`java -javaagent`)을 통해 클래스 로더 조작기를 지정해야 함
## 3️⃣ 런타임 (프록시)
### 위빙
![](https://i.imgur.com/As10DI2.png)
- 컴파일이 다 끝나고, 클래스 로더에 클래스도 다 올라가서 이미 자바의 메인 메서드가 실행된 후에 부가 기능을 적용
- 스프링과 같은 컨테이너의 도움을 받고 프록시와 DI, 빈 포스트 프로세서 같은 개념들을 동원
### 단점
- 프록시를 사용하기 때문에 AOP 기능에 일부 제약
	- 조인 포인트는 메서드 실행으로 제한
	- 스프링 컨테이너가 관리할 수 있는 스프링 빈에만 AOP를 적용
# 용어
![](https://i.imgur.com/pqnPsVU.png)
## 1️⃣ 조인 포인트
- 어드바이스가 적용될 수 있는 위치, 메소드 실행, 생성자 호출, 필드 값 접근, static 메서드 접근 같은 프로그램 실행 중 지점
- AOP를 적용할 수 있는 모든 지점
	- 스프링 AOP는 프록시 방식을 사용하므로 항상 메서드 시점으로 제한된다.
### 기능
- `getArgs()` : 메서드 인수 반환
- `getThis()` : 프록시 객체 반환
- `getTarget()` : 대상 객체 반환
- `getSignature()` : 조인되는 메서드에 대한 설명 반환
- `toString()` : 조인되는 방법에 대한 유용한 설명
## 2️⃣ 포인트컷
- 조인 포인트 중 어드바이스가 적용될 위치를 선별하는 기능
- 주로 AspectJ 표현식을 사용해서 지정
### `@Pointcut`
- 포인트컷 표현식 사용
- **포인트컷 시그니처** : 메서드 이름 + 파라미터
- 메서드의 반환 타입은 `void`여야 한다.
- 코드 내용은 비워둔다.
### PCD
- 포인트컷 지시자 (Pointcut Designator)
#### 종류
- `execution`
	- 메서드 실행 조인 포인트 매칭
	- `execution(접근제어자? 반환타입 선언타입?메서드이름(파라미터) 예외?)`
	- 메서드 부모 타입 지정 O, 파라미터 부모 타입 X (시그니처 판단 - 정적)
- `within` : 특정 타입 내의 조인 포인트 매칭
	- 메서드 부모 타입 지정 X
- `args` : 인자가 주어진 타입의 인스턴스인 조인 포인트
	- 파라미터 부모 타입 O (인스턴스 판단 - 동적)
- `this` : 스프링 빈 객체 (스프링 AOP 프록시)를 대상으로 하는 조인 포인트
- `target` : Target 객체 (스프링 AOP 프록시가 가리키는 실제 대상)를 대상으로 하는 조인 포인트
- `@target` : 실행 객체의 클래스에 주어진 타입의 애노테이션이 있는 조인 포인트
	- 인스턴스의 모든 메서드를 조인포인트로 적용 (부모 타입 지정 O)
- `@within` : 주어진 애노테이션이 있는 타입 내 조인 포인트
	- 해당 타입 내에 있는 메서드만 조인 포인트로 적용 (부모 타입 지정 X)
- `@annotation` : 메서드가 주어진 애노테이션을 가지고 있는 조인 포인트
- `@args` : 전달된 실제 인수의 런타임 타입이 주어진 타입의 애노테이션을 갖는 조인 포인트
- `bean` : 스프링 전용 포인트컷 지시자, 빈의 이름으로 포인트컷 지정

> `arg`, `@args`, `@target`은 단독으로 사용 불가하다.
> 위 PCD는 실제 객체 인스턴스가 생성되고 실행될 때 어드바이스 적용 여부를 확인할 수 있으며, 프록시가 없다면 판단 자체가 불가능하다.
> 하지만 스프링 컨테이너가 프록시를 생성하는 시점은 스프링 컨테이너가 만들어지는 애플리케이션 로딩 시점이다.
> 따라서 위의 포인트컷 지시자가 있을 경우, 스프링은 모든 스프링 빈에 AOP를 적용하려고 시도한다.
> 모든 스프링 빈에 AOP 프록시를 적용하려고 할 경우, 스프링이 내부에서 사용하는 빈 중 `final`로 지정된 빈들이 있어 오류가 발생할 수 있다.
> 따라서 프록시 적용 대상을 축소하는 표현식과 함께 사용해야 한다.
## 3️⃣ 타겟
- 어드바이스를 받는 객체
- 포인트컷으로 결정
## 4️⃣ 어드바이스
- 부가 기능
- 특정 조인 포인트에서 Aspect에 의해 취해지는 조치
- Around, Before, After 등이 있음
### 순서
- 어드바이스를 각각의 애스펙트로 분리하고, `@Order` 애노테이션을 통해 실행 순서를 적용한다.
	- 숫자가 작을 수록 먼저 실행된다.
### 종류
```java
@Around("hello.aop.order.aop.Pointcuts.orderAndService()")  
public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable {  
    try {  
       // @Before  
       log.info("[트랜잭션 시작] {}", joinPoint.getSignature());  
  
       Object result = joinPoint.proceed();  
  
       // @AfterReturning  
       log.info("[트랜잭션 커밋] {}", joinPoint.getSignature());  
  
       return result;  
    } catch (Exception e) {  
       // @AfterThrowing  
       log.info("[트랜잭션 롤백] {}", joinPoint.getSignature());  
       throw e;  
    } finally {  
       // @After  
       log.info("[리소스 릴리즈] {}", joinPoint.getSignature());  
    }  
}
```
- `@Around`
	- 메서드 호출 전후에 수행
	- 가장 강력한 어드바이스
	- 조인 포인트 실행 여부 선택, 반환 값 변환, 예외 변환 등이 가능
		- 조인 포인트를 실행할 수 있는 기능이 있으므로 `proceed()`가 있는 `ProceedingJoinPoint`를 사용
		- `proceed()`를 여러번 실행할 수 있음
- `@Before`
	- 조인 포인트 실행 이전에 실행
	- 메서드 종료 시 자동으로 다음 타겟이 호출
	- 예외가 발생하면 다음 코드가 호출되지 않음
- `@AfterReturning` 
	- 조인 포인트가 정상 완료 후 실행
	- 리턴값을 반환하지 않기 때문에 변경은 불가
	- `returning` 속성에 사용된 이름은 어드바이스 메서드의 매게변수 이름과 일치해야함
	- `returning` 절에 지정된 타입의 값을 반환하는 메서드만 대상으로 실행
- `@AfterThrowing`
	- 메서드가 예외를 던지는 경우 실행
	- `throwing` 속성에 사용된 이름은 어드바이스 메서드의 매게변수 이름과 일치해야 함
	- `throwing` 절에 지정된 타입과 맞는 예외를 대상으로 실행
- `@After`
	- 조인 포인트가 정상 또는 예외에 관계없이 실행 (finally)
	- 정상 및 예외 반환 조건 모두 처리
	- 일반적으로 리소스를 해제하는데 사용
### 우선순위
![](https://i.imgur.com/0uHgr5C.png)
- 스프링 5.2.7버전부터 동일한 `@Aspect` 안에서 동일한 조인포인트의 우선순위 존재
	- `@Around` -> `@Before` -> `@After` -> `@AfterReturning` -> `@AfterThrowing`
- 호출 순서와 리턴 순서는 반대
## 5️⃣ 애스펙트 
- 어드바이스 + 포인트컷
- `@Aspect`
- 여러 어드바이스와 포인트컷이 함께 존재
## 6️⃣ 어드바이저
- 하나의 어드바이스와 하나의 포인트 컷
- 스프링 AOP에서만 사용
## 7️⃣ 위빙
- 포인트컷으로 결정한 타겟의 조인 포인트에 어드바이스를 적용하는 것
- 핵심 기능 코드에 영향을 주지 않고 부가 기능을 추가
- AOP 적용을 위해 애스펙트를 객체에 연결한 상태
	- 컴파일 타임
	- 로드 타임
	- 런타임
## 8️⃣ AOP 프록시
- AOP 기능을 구현하기 위해 만든 프록시 객체
- 스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시