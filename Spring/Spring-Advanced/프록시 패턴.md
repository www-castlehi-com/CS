## 정의
![](https://i.imgur.com/Ga1fSo0.png)
- 대리자를 통해 간접적으로 서버에 요청하는 패턴
- 런타임에 클라이언트 객체에 DI를 사용해서 `Client -> Server`에서 `Client -> Proxy`로 의존관계를 변경해도 클라이언트 코드를 변경하지 않도록 함
### 체인
![](https://i.imgur.com/fEg4zI2.png)
### vs [[데코레이터 패턴]]
- 의도에 따라 구분
#### 공통점
- 프록시 사용
#### 차이점
- 프록시 패턴 : **접근 제어**
- 데코레이터 패턴 : **새로운 기능 추가**
## 기능
### 1️⃣ 접근 제어
- 권한에 따른 접근 차단
- 캐싱
- 지연 로딩
### 2️⃣ 부가 기능 추가
- 원래 서버가 제공하는 기능 + 부가 기능
## 인터페이스 기반 vs 클래스 기반

### 차이점
- 클래스 기반은 해당 클래스에만 적용할 수 있고, 인터페이스 기반은 인터페이스에만 같으면 모든 곳에 적용할 수 있음
- 클래스 기반 프록시는 상속을 사용
	- 부모 클래스의 생성자 호출
	- 클래스에 final 키워드가 붙으면 상속 불가
	- 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩 할 수 없음
- 인터페이스 기반은 인터페이스가 필요하므로 결합도가 증가함
### 구현 방향
- 구현을 별경할 가능성이 거의 없을 경우 구체 클래스를 바로 사용하고, 구현을 변경할 가능성이 있을 경우 인터페이스를 사용
## 한계
### 1️⃣ 타입 캐스팅
![](https://i.imgur.com/ypQcqua.png)
- JDK 동적 프록시는 `MemberService` 인터페이스를 기반으로 프록시를 생성한다.
![](https://i.imgur.com/DvMIsrg.png)
- JDK Proxy는 `MemberService`로 캐스팅이 가능하지만 구현체는 전혀 알지 못하므로 구현체로의 캐스팅은 불가능하다.
- 캐스팅을 시도할 시 `ClassCastException.class` 예외가 발생한다.
### 2️⃣ 의존 관계 주입
![](https://i.imgur.com/utaGNVR.png)
- JDK Proxy가 구체 클래스를 주입할 수 없으므로 구체 클래스 직접 주입 시 오류가 발생한다.

> - DI를 사용하므로 클라이언트의 코드의 변경 없이 구현 클래스를 변경하기 위해서는 인터페이스를 기반으로 의존 관계를 주입 받아야한다.
> - 구현 클래스를 의존관계에 주입하면 향후 구현 클래스를 변경할 때 의존관계 주입을 받는 클라이언트의 코드도 함께 변경해야 한다.
> - AOP 프록시가 적용된 구체 클래스를 직접 의존관계 주입 받아야 하는 경우는 CGLIB를 통해 구체 클래스 기반으로 AOP 프록시를 적용한다.
### 3️⃣ CGLIB
#### 1) 대상 클래스에 기본 생성자 필수
- CGLIB는 구체 클래스를 상속 받는다.
- 자바 언어에서 상속을 받으면 자식 클래스의 생성자를 호출할 때 자식 클래스의 생성자에서 부모 클래스의 생성자도 호출해야 한다.
	- 코드에서 생략될 경우 `super()`가 자동으로 호출된다.
- CGLIB 프록시는 대상 클래스를 상속 받고, 생성자에서 대상 클래스의 기본 생성자를 호출하므로 대상 클래스에 기본 생성자를 만들어야 한다.
#### 2) 생성자 2번 호출 문제
- 실제 target의 객체를 생성할 때
- 프록시 객체를 생성할 때 부모 클래스의 생성자 호출
#### 3) final 키워드 클래스, 메서드 사용 불가
- final 키워드가 클래스에 있으면 상속이 불가능하고, 메서드에 있으면 오버라이딩이 불가능하다.
- CGLIB는 상속을 기반으로 하기 때문에 final 키워드가 있을 경우 정상 동작하지 않는다.
## 스프링의 해결책
### 스프링 3.2
- CGLIB를 사용하려면 CGLIB 라이브러리가 별도로 필요했다.
- 스프링 3.2부터는 별도의 라이브러리 추가 없이 CGLIB를 사용할 수 있게 되었다.
### 스프링 4.0
- `objenesis`라는 라이브러리를 사용해서 기본 생성자 없이 객체 생성이 가능하게 되었다.
	- 생성자 호출 없이 객체를 생성할 수 있게 해준다.
- `objenesis` 라이브러리를 사용해 생성자 2번 호출 문제가 해결되었다.
### 스프링부트 2.0
- CGLIB를 기본으로 사용하도록 한다.
	- `@SpringBootTest`를 사용할 시 CGLIB가 기본으로 사용된다.
- 별도의 설정이 없다면 AOP를 적용할 때 `proxyTargetClass=true`로 설정해서 사용한다.
- 인터페이스가 있어도 JDK 동적프록시를 사용하지 않으며 항상 CGLIB를 사용해서 구체클래스를 기반으로 프록시를 생성한다.
	- `application.properties`에서 JDK 동적 프록시 설정을 사용할 수 있다.

> `final` 클래스, 메서드는 해결되지 않았지만 AOP를 적용할 대상에는 `final` 키워드를 잘 사용하지 않는다.