# 문제
- 스프링은 프록시 방식의 [[Spring/Spring-Advanced/AOP|AOP]]를 사용한다.
	- AOP를 적용하려면 항상 프록시를 통해서 대상 객체를 호출해야 한다.
	- 프록시에서 먼저 어드바이스를 호출하고, 이후에 대상 객체를 호출한다.
- 프록시를 거치지 않고 대상 객체를 직접 호출하게 되면 AOP가 적용되지 않고, 어드바이스도 호출되지 않는다.
![](https://i.imgur.com/QlVcV3q.png)
- `this`는 자신의 인스턴스를 가리키며, 프록시가 아닌 실제 대상 객체의 인스턴스를 의미한다.
- `this`로 호출된 내부 메서드는 프록시가 아니기 때문에 AOP가 적용되지 않는다.

> AspectJ를 직접 사용하면 이런 문제가 발생하지 않는다.
> 프록시를 통하는 것이 아니라 해당 코드에 직접 AOP 적용 코드가 붙어 있기 때문이다.
> 설정이 복잡하고, JVM 옵션을 주어야 하는 부담이 있기 때문에 실무에서는 거의 사용하지 않는다.
# 대안
## 1️⃣ 자기 자신 주입
### 흐름
![](https://i.imgur.com/OlDo4rb.png)
- 스프링에서 AOP가 적용된 대상을 의존관계 주입 받을 경우 대상은 실제 객체가 아닌 프록시 객체가 된다.
### 코드
#### 1. 수정자
```java
@Slf4j
@Component
public class CallServiceV1 {

	private CallServiceV1 callServiceV1;
	
	@Autowired
	public void setCallServiceV1(CallServiceV1 callServiceV1) {
		this.callServiceV1 = callServiceV1;
	}
	
	public void external() {
		log.info("call external");
		callServiceV1.internal();
	}
	
	public void internal() {
		log.info("call internal");
	}
}
```
- 생성자 주입은 본인을 생성하면서 주입해야 하기 때문에 순환 사이클이 만들어진다.
- 수정자 주입은 스프링이 생성된 이후에 주입할 수 있기 때문에 오류가 발생하지 않는다.
#### 2. 지연 로딩
#####  1) ApplicationContext
```java
@Slf4j  
@Component  
public class CallServiceV2 {  
  
    private final ApplicationContext applicationContext;  
    
    public CallServiceV2(ApplicationContext applicationContext) {
	    this.applicationContext = applicationContext;
    }
  
    public void external() {  
       log.info("call external");  
       CallServiceV2 callServiceV2 = applicationContext.getBean(CallServiceV2.class);  
       callServiceV2.internal();  
    }  
  
    public void internal() {  
       log.info("call internal");  
    }  
}
```
- `ApplicationContext`는 너무 많은 기능을 제공한다.
##### 2) ObjectProvider
```java
@Slf4j  
@Component  
public class CallServiceV2 {  
  
    private final ObjectProvider<CallServiceV2> callServiceProvider;  
  
    public CallServiceV2(ObjectProvider<CallServiceV2> callServiceProvider) {  
       this.callServiceProvider = callServiceProvider;  
    }  
  
    public void external() {  
       log.info("call external");  
       CallServiceV2 callServiceV2 = callServiceProvider.getObject();  
       callServiceV2.internal();  
    }  
  
    public void internal() {  
       log.info("call internal");  
    }  
}
```
- `ObjectProvider`는 객체를 스프링 컨테이너에서 조회하는 것을 스프링 빈 생성 시점이 아니라 실제 객체를 사용하는 시점으로 지연할 수 있다.
- `getObject()`를 호출하는 시점에 스프링 컨테이너에서 빈을 조회한다.
## 2️⃣ 구조 변경
- 내부 호출을 별도의 클래스로 분리
### 흐름
![](https://i.imgur.com/4b5iF4K.png)

> 클라이언트가 같은 클래스의 `external()`, `internal()`을 따로 호출하는 방법도 존재한다.
> 이 때, `external()`은 `internal()`을 호출하지 않도록 해야한다.
