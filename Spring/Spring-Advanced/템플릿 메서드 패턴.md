## 정의
- 템플릿을 사용하는 방식
	- 템플릿 : 기준이 되는 거대한 틀
- 다형성 사용하여 변하는 부분과 변하지 않는 부분을 분리
## 구조
![](https://i.imgur.com/4fHKfm4.png)
## 예시
### 클래스
**추상 템플릿 클래스**
```java
@Slf4j  
public abstract class AbstractTemplate {  
  
    public void execute() {  
       long startTime = System.currentTimeMillis();  
       // 비즈니스 로직 실행  
       call();  
       // 비즈니스 로직 종료  
       long endTime = System.currentTimeMillis();  
       long resultTime = endTime - startTime;  
       log.info("resultTime = {}", resultTime);  
    }  
  
    protected abstract void call();  
}
```
**인스턴스 클래스**
```java
@Slf4j  
public class SubClassLogic1 extends AbstractTemplate {  
  
    @Override  
    protected void call() {  
       log.info("비즈니스 로직1 실행");  
    }  
}

@Slf4j  
public class SubClassLogic2 extends AbstractTemplate {  
  
    @Override  
    protected void call() {  
       log.info("비즈니스 로직2 실행");  
    }  
}
```
### 결과
```shell
INFO hello.advanced.trace.template.SubClassLogic1 -- 비즈니스 로직1 실행
INFO hello.advanced.trace.template.code.AbstractTemplate -- resultTime = 1
INFO hello.advanced.trace.template.SubClassLogic2 -- 비즈니스 로직2 실행
INFO hello.advanced.trace.template.code.AbstractTemplate -- resultTime = 0
```
### 흐름
![](https://i.imgur.com/IXRO3YR.png)
## 단점
### 1. 인스턴스 클래스 생성
- 인스턴스 클래스를 계속 만들어야 함
#### 해결 방법
##### 익명 내부 클래스
- 객체 인스턴스를 생성하면서 동시에 생성할 클래스를 상속 받은 자식 클래스를 정의
- 직접 지정하는 이름이 없고 클래스 내부에 선언되는 클래스
###### 예시
```java
@Test  
void templateMethodV2() {  
    AbstractTemplate template1 = new AbstractTemplate() {  
       @Override  
       protected void call() {  
          log.info("비즈니스 로직1 실행");  
       }  
    };  
    template1.execute();  
  
    AbstractTemplate template2 = new AbstractTemplate() {  
       @Override  
       protected void call() {  
          log.info("비즈니스 로직2 실행");  
       }  
    };  
    template2.execute();  
}
```
### 2. 강한 결합
- 자식 클래스 입장에서는 부모 클래스의 기능을 전혀 사용하지 않지만 상속받아야 함
- 부모 클래스를 수정하면 자식 클래스에도 영향을 줄 수 있음
#### 해결 방법
##### [[전략 패턴]]
