# BeanPostProcessor
## 1. 목적
- 스프링이 빈 저장소에 등록할 목적으로 생성한 객체를 빈 저장소에 등록하기 직전에 조작
### 1) 너무 많은 설정
```java
@Bean  
public OrderControllerV1 orderControllerV1(LogTrace logTrace) {  
    OrderControllerV1 orderController = new OrderControllerV1Impl(orderServiceV1(logTrace));  
    ProxyFactory factory = new ProxyFactory(orderController);  
  
    factory.addAdvisor(getAdvisor(logTrace));  
    OrderControllerV1 proxy = (OrderControllerV1)factory.getProxy();  
    log.info("ProxyFactory proxy={}, target={}", proxy, orderController);  
  
    return proxy;  
}  
  
//...
```
- 프록시를 직접 스프링 빈으로 등록하려 할 경우 설정 파일에 프록시 관련 설정이 지나치게 많아진다.
### 2) 컴포넌트 스캔
- 직접 프록시를 적용할 경우 원본 객체 대신 프록시를 만들어 스프링 컨테이너에 빈으로 등록해야 하는데, 컴포넌트 스캔은 원본 객체를 자동 등록하기 때문에 직접 적용은 불가능하다.
## 2. 기능
- 객체 조작
- 완전히 다른 객체로 바꾸기
## 3. 과정
![](https://i.imgur.com/KbV0hRv.png)
![](https://i.imgur.com/ThVhyAE.png)
1. **생성** : 스프링 빈 대상이 되는 객체 생성
2. **전달** : 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달
3. **후 처리 작업** : 전달된 스프링 빈 객체를 조작하거나 다른 객체로 바꿔치기
4. **등록** : 빈을 반환
## 4. 인터페이스
```java
public interface BeanPostProcessor {  
    @Nullable  
    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {  
        return bean;  
    }  
  
    @Nullable  
    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {  
        return bean;  
    }  
}
```
- `postProcessBeforeInitialization` : 객체 생성 이후에 `@PostConstruct`같은 초기화가 발생하기 전에 호출되는 포스트 프로세서
- `postProcessAfterInitialization` : 객체 생성 이후에 `@PostConstruct` 같은 초기화가 발생한 다음에 호출되는 포스트 프로세서
## 5. 주의
### 프록시 적용 대상 여부 체크
- `basePackage`를 사용해서 특정 패키지를 기준으로 프록시 체크를 하는 것도 좋지만, PointCut을 활용하는 것이 더 좋다.
	1. 프록시 적용 대상 여부를 체크해서 꼭 필요한 곳에만 프록시를 적용한다. (빈 후처리기 - 자동 프록시 생성)
	2. 프록시의 어떤 메서드가 호출되었을 때 어드바이스를 적용할 지 판단한다. (프록시 내부)
- 스프링 부트가 기본으로 제공하는 빈 중에는 프록시 객체로 만들 수 없는 빈들도 있다.
# 스프링 제공
## library
```gradle
implementation 'org.springframework.boot:spring-boot-starter-aop'
```
- `aspectjweaver`라는 `aspectJ` 관련 라이브러리 등록
- 스프링 부트가 AOP 관련 클래스를 자동으로 스프링 빈에 등록 (스프링 부트가 없을 경우 `@EnableAspectJAutoProxy`를 직접 사용)
- `AopAutoConfiguration` : 스프링 부트가 활성화하는 빈
## AutoProxyCreator
- 자동 프록시 생성기인 `AnnotationAwareAspectJAutoProxyCreator` 빈 후처리기가 스프링 빈에 자동 등록
- 스프링 빈으로 등록된 `Advisor` 들을 자동으로 찾아 필요한 곳에 자동으로 프록시 적용
	- `Pointcut`, `Advice`가 모두 포함되어 있으므로, `Pointcut`으로 어떤 스프링 빈에 프록시를 적용해야 할지 판단하고, `Advice`로 부가 기능을 적용한다.
- `@AspectJ`도 자동으로 인식해서 프록시를 만들고 AOP를 적용한다.
## 과정
![](https://i.imgur.com/X3wbXQv.png)
1. **생성** : 스프링이 스프링 빈 대상이 되는 객체 생성 (`@Bean`, 컴포넌트 스캔 모두 포함)
2. **전달** : 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달
3. **모든 Advisor 빈 조회** : 자동 프록시 생성기 빈 후처리기가 스프링 컨테이너에서 모든 `Advisor`를 조회
4. **프록시 적용 대상 체크** : `Advisor`에 포함되어 있는 포인트컷을 사용해서 객체의 클래스 정보 뿐만 아니라 객체 내 모든 메서드를 포인트컷에 매칭하여 해당 객체가 프록시를 적용할 대상인지 아닌지 판단
5. **프록시 생성** : 프록시 적용 대상이면 프록시를 생성하고 반환해서 프록시를 스프링 빈으로 등록하고, 적용 대상이 아니라면 원본 객체를 빈으로 등록
6. **빈 등록**
## 여러 advisor
![](https://i.imgur.com/TmfOXRR.png)
- 여러 advisor를 모두 만족해야만 프록시가 생성됨
- 프록시는 1개만 생성
## `@Aspect` 프록시
### 개요
- 스프링이 제공하는 [[포인트컷, 어드바이스, 어드바이저]]

> `@Aspect`는 관점 지향 프로그래밍 (AOP)를 가능하게 하는 AspectJ 프로젝트에서 제공하는 애노테이션이다.
> 스프링은 이를 차용해서 프록시를 통한 AOP를 가능하게 한다.
### 사용법
```java
@Slf4j  
@Aspect  
public class LogTraceAspect {  
  
    //... 
  
    @Around("execution(* hello.proxy.app..*(..))")  
    public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {  
       TraceStatus status = null;  
       try {  
          String message = joinPoint.getSignature().toShortString();  
          status = logTrace.begin(message);  
  
          // 로직 호출  
          Object result = joinPoint.proceed();  
  
          logTrace.end(status);  
  
          return result;  
       } catch (Exception e) {  
          logTrace.exception(status, e);  
          throw e;  
       }  
    }  
}
```
- `@Aspect` : 애노테이션 기반 프록시 적용
- `@Around("execution(...)")`
	- `@Around`의 값에 포인트컷 표현식을 넣는다.
	- 표현식은 AspectJ 표현식을 사용한다.
	- `@Around` 메서드는 어드바이스(`Advice`)가 된다.
- `ProceedingJoinPoint joinPoint` : 내부에 실제 호출 대상, 전달 인자, 어떤 객체와 어떤 메서드가 호출되었는지 정보가 포함
- `joinPoint.proceed()` : 실제 호출 대상 (`target`) 호출
###  원리
- 자동 프록시 생성기가 처리
![](https://i.imgur.com/9anGWhD.png)
1. **실행** : 스프링 애플리케이션 로딩 시점에 자동 프록시 생성기 호출
2. **생성** : 스프링이 빈 대상이 되는 객체 생성 (`@Bean`, 컴포넌트 스캔 모두 포함)
3. **조회** : 스프링 컨테이너에서 `Advisor` 빈과 `@Aspect` 어드바이저 빌더 내부에 저장된 `Advisor`를 모두 조회
	- `@Aspect` 어드바이저 빌더는 `@Aspect` 애노테이션 정보를 기반으로 어드바이저 생성하여 내부에 저장
4. **프록시 적용 대상 체크** : `Advisor`에 포함되어 있는 포인트컷을 사용해서 해당 객체가 프록시를 적용할 대상인지 아닌지 판단
	- 객체의 클래스 정보 뿐만 아니라, 해당 객체의 모든 메서드를 포인트컷에 하나하나 모두 매칭해보고 하나라도 만족하면 프록시 적용 대상으로 간주한다.
5. **프록시 생성** : 프록시 적용 대상에 프록시를 생성하고 반환하여 스프링 빈으로 등록하고, 프록시 적용 대상이 아닐 경우 원본 객체를 빈으로 등록
6. **빈 등록** : 반환된 객체는 스프링 빈으로 등록

> **`@Aspect` 어드바이저 빌더**
> - `BeanFactoryAspectJAdvisorBuilder` 크래스
> - `@Aspect` 정보를 기반으로 포인트컷, 어드바이스, 어드바이저를 생성하고 보관
> - `@Aspect`의 정보를 기반으로 어드바이저를 만들고, `@Aspect` 어드바이저 빌더 내부 저장소에 캐시
> - 캐시에 어드바이저가 이미 만들어져 있는 경우 캐시에 저장된 어드바이저를 반환
#### 2) 어드바이저를 기반으로 프록시 생성
