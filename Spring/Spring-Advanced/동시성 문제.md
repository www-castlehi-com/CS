## 개념
- 여러 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제
- 트래픽이 점점 많아질 수록 자주 발생
- 싱글톤 객체의 필드를 변경하며 사용할 때 발생

> 지역 변수에서는 발생하지 않는다. 지역 변수는 쓰레드마다 각각 다른 메모리 영역이 할당되기 때문이다.
> 동시성 문제가 자주 발생하는 곳은 **인스턴스 필드**, static 같은 **공용 필드**에 접근할 때 발생한다.
> 값을 읽기만 하면 발생하지 않으며, 값을 어디선가 변경할 때 발생한다.
## 코드
```java
@Slf4j  
public class FieldService {  
  
    private String nameStore;  
  
    public String logic(String name) {  
       log.info("저장 name={} -> nameStore={}", name, nameStore);  
       nameStore = name;  
       sleep(1000);  
       log.info("조회 nameStore={}", nameStore);  
       return nameStore;  
    }
}
```
```java
@Test  
void field() {  
    log.info("main start");  
    Runnable userA = () -> fieldService.logic("userA");  
    Runnable userB = () -> fieldService.logic("userB");  
  
    Thread threadA = new Thread(userA);  
    threadA.setName("thread-A");  
    Thread threadB = new Thread(userB);  
    threadB.setName("thread-B");  
  
    threadA.start();  
    sleep(100);    // 동시성 문제 발생 O    
    threadB.start();  
  
    sleep(3000);   // 메인 쓰레드 종료 대기  
    log.info("main exit");  
}
```
## 동작
![](https://i.imgur.com/YA7A3Uh.png)
![](https://i.imgur.com/ToNjW61.png)
- `thread-A` 호출이 끝나면서 `nameStore`의 결과를 반환받는데, `userB`의 `logic()`으로 인해 같은 `nameStore`를 변경해버려 `userA`가 아니라 변경된 값을 반환받게 됨