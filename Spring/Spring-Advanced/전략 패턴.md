## 정의
- 변하지 않는 부분을 `Context`에 두고, 변하는 부분을 `Strategy`라는 인터페이스를 만들고 해당 인터페이스를 구현하도록 함
	- `Context` : 변하지 않는 템플릿
	- `Strategy` : 변하는 알고리즘
- 상속이 아닌 **위임**
- ex) 스프링에서 의존관계 주입 방식

>_GOF 디자인 패턴_
>알고리즘 제품군을 정의하고 각각을 캡슐화하여 상호 교환하게 만들자. 전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.
## 구조
![](https://i.imgur.com/B4Uxh9M.png)
## 예시
### 클래스
#### Strategy
**인터페이스**
```java
public interface Strategy {  
  
    void call();  
}
```
**구현**
```java
@Slf4j  
public class StrategyLogic1 implements Strategy {  
  
    @Override  
    public void call() {  
       log.info("비즈니스 로직1 실행");  
    }  
}

@Slf4j  
public class StrategyLogic2 implements Strategy {  
  
    @Override  
    public void call() {  
       log.info("비즈니스 로직2 실행");  
    }  
}
```
#### Context
```java
@Slf4j  
public class ContextV1 {  
  
    private Strategy strategy;  
  
    public ContextV1(Strategy strategy) {  
       this.strategy = strategy;  
    }  
  
    public void execute() {  
       long startTime = System.currentTimeMillis();  
       // 비즈니스 로직 실행  
       strategy.call(); //위임  
       // 비즈니스 로직 종료  
       long endTime = System.currentTimeMillis();  
       long resultTime = endTime - startTime;  
       log.info("resultTime = {}", resultTime);  
    }  
}
```
### 테스트
```java
@Test  
void strategyV2() {  
    Strategy strategyLogic1 = new Strategy() {  
       @Override  
       public void call() {  
          log.info("비즈니스 로직1 실행");  
       }  
    };  
    ContextV1 context1 = new ContextV1(strategyLogic1);  
    log.info("strategyLogic1={}", strategyLogic1.getClass());  
    context1.execute();  
  
    Strategy strategyLogic2 = new Strategy() {  
       @Override  
       public void call() {  
          log.info("비즈니스 로직2 실행");  
       }  
    };  
    ContextV1 context2 = new ContextV1(strategyLogic2);  
    log.info("strategyLogic2={}", strategyLogic2.getClass());  
    context2.execute();  
}

/**
* lambda
*/
@Test  
void strategyV4() {  
    ContextV1 context1 = new ContextV1(() -> log.info("비즈니스 로직1 실행"));  
    context1.execute();  
  
    ContextV1 context2 = new ContextV1(() -> log.info("비즈니스 로직2 실행"));  
    context2.execute();  
}
```
### 결과
```Shell
INFO hello.advanced.trace.strategy.code.strategy.StrategyLogic1 -- 비즈니스 로직1 실행
INFO hello.advanced.trace.strategy.code.strategy.ContextV1 -- resultTime = 1
INFO hello.advanced.trace.strategy.code.strategy.StrategyLogic2 -- 비즈니스 로직2 실행
INFO hello.advanced.trace.strategy.code.strategy.ContextV1 -- resultTime = 1
```
### 흐름
![](https://i.imgur.com/uwjT2c9.png)
1. `Context`에 원하는 `Strategy` 구현체 주입
2. 클라이언트는 `Context` 실행
3. `Context`는 `Context` 로직 시작
4. `Context`는 로직 중간에 `Strategy.call()`을 호출해서 주입 받은 `Strategy`에게 로직 위임
5. `Context`는 나머지 로직 실행
## 단점
### 1) 사용 전 조립
- 조립 후 전략을 변경하기 번거로움
- `setter`를 제공해 `Strategy`를 넘겨 받아 변경할 수 있지만, `Context`를 싱글톤으로 사용할 때에는 동시성 이슈 등 고려해야 할 점이 많음
#### 해결방법
##### 개요
- 파라미터 전달 ([[템플릿 콜백 패턴]])
##### 예시
```java
@Slf4j  
public class ContextV2 {  
  
    public void execute(Strategy strategy) {  
       long startTime = System.currentTimeMillis();  
       // 비즈니스 로직 실행  
       strategy.call(); //위임  
       // 비즈니스 로직 종료  
       long endTime = System.currentTimeMillis();  
       long resultTime = endTime - startTime;  
       log.info("resultTime = {}", resultTime);  
    }  
}
```
##### 흐름
![](https://i.imgur.com/GUmWAQt.png)
1. 클라이언트는 `Context`를 실행하면서 인수로 `Strategy` 전달
2. `Context`는 `execute()` 로직 실행
3. `Context`는 파라미터로 넘어온 `Strategy.call()` 로직 실행
4. `Context`의 `execute()` 로직 종료
