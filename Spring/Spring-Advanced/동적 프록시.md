- 개발자가 직접 프록시 클래스를 만들지 않아도 됨
- 프록시 객체를 동적으로 런타임에 대신 만들고, 원하는 실행 로직을 저장할 수 있음
# 1️⃣ JDK 동적 프록시
## 1. 개요
- 인터페이스(`InvocationHandler`) 기반
## 2. 사용법
### 생성
- `Proxy.newProxyInstance(classLoader(), new Class[]{AInterface.class}, handler)`
	- 동적 프록시는 `java.lang.reflect.Proxy`를 통해 생성
### 파라미터
- 클래스 로더 정보, 인터페이스, 핸들러 로직
- 해당 인터페이스 기반으로 동적 프록시를 생성하고 결과 반환
### 결과
`proxyClass=class com.sun.proxy.$Proxy1`
- JDK 동적 프록시가 동적으로 만들어준 프록시
- 핸들러 로직을 실행
## 3. 실행 순서
![](https://i.imgur.com/eIcLrbY.png)
1. 클라이언트는 JDK 동적 프록시의 `call()` 실행
2. JDK 동적 프록시는 `InvocationHandler.invoke()` 호출
3. 핸들러가 내부 로직을 수행하고, `method.invoke(target, args)`를 호출해서 실제 객체를 호출
4. 실제 객체의 `call()` 실행
5. 핸들러로 응답 반환
# 2️⃣ CGLIB
## 1. 개요
- 바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리
- 인터페이스가 없어도 구체 클래스만 가지고 동적 프록시를 만들 수 있음
- 외부 라이브러리였지만, 스프링 프레임워크에 포함됨
- `MethodInterceptor`를 사용
- 상속을 사용하기 때문에 상속에 대한 제약 존재

> 직접 사용하는 경우는 거의 없으며, 스프링의 `ProxyFactory`라는 것이 사용하고 이를 이용

```java
package org.springframework.cglib.proxy;

public interface MethodInterceptor extends Callback {
	Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable;
}
```
- `obj` : CGLIB가 적용된 객체
- `method` :  호출된 메서드
- `args` : 메서드를 호출하면서 전달된 인수
- `proxy` : 메서드 호출에 사용
## 2. 사용법
```java
Enhancer enhancer = new Enhancer();  
enhancer.setSuperclass(ConcreteService.class);  
enhancer.setCallback(new TimeMethodInterceptor(target));  
ConcreteService proxy = (ConcreteService)enhancer.create();   
  
proxy.call();
```
- `Enhancer` 사용
- `enhancer.setSuperclas(.class)` : 구체 클래스를 상속 받아서 프록시 생성
- `enhancer.setCallback(new MethodInterceptor(target))` : 프록시에 적용할 실행 로직 할당
- `enhancer.create()` : superClass에서 지정한 클래스를 상속 받아서 프록시 생성
## 3. 실행 순서
### 클래스 의존 관계
![](https://i.imgur.com/V1HxVqz.png)
### 런타임 객체 의존 관계
![](https://i.imgur.com/oAk2Av6.png)
