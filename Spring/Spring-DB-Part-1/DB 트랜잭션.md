# 데이터베이스 연결 구조와 DB 세션
![](https://i.imgur.com/Qt0btxn.png)
- 사용자는 WAS나 DB 접근 툴 같은 클라이언트를 사용해서 데이터베이스 서버에 접근
- 클라이언트는 데이터베이스 서버에 연결을 요청하고 커넥션을 맺음
- 데이터베이스는 내부에 세션을 생성함
- 해당 커넥션을 통한 모든 요청은 생성한 세션을 통해서 실행
- 세션은 [[트랜잭션]]을 시작하고, 커밋 또는 로백을 통해 트랜잭션 종료하며 이후에 새로운 트랜잭션을 다시 시작
- 사용자가 커넥션을 닫거나, 세션을 강제로 종료하면 세션이 종료됨
![](https://i.imgur.com/DCR0cjY.png)
- 커넥션의 개수마다 세션이 만들어짐
# 동작
- 데이터 변경 쿼리를 실행하고 결과를 반영하려면 `commit`을 호출하고, 결과를 반영하고 싶지 않으면 `rollback`을 호출
![](https://i.imgur.com/dx8IYXT.png)
- 커밋을 호출하기 전까지는 임시로 데이터를 저장
- 해당 트랜잭션을 시작한 세션에게만 변경 데이터가 보이고 다른 세션에게는 변경 데이터가 보이지 않음
	- 격리 수준이 `READ UNCOMMITTED`라면 다른 세션에도 보임
- 다른 세션에 보일 경우 추가한 세션에서 `rollback`을 할 경우 모든 데이터가 처음 상태로 복구되어 데이터 정합성에 문제가 발생함
# 커밋
## 자동 커밋
- 각각의 쿼리 실행 직후에 자동으로 `commit` 호출
- `commit`이나 `rollback`을 직접 호출하지 않아도 됨
## 수동 커밋
- 대부분 자동 커밋 모드가 기본
- 수동 커밋 모드로 설정한는 것을 트랜잭션을 시작한다고 표현
- `commit`, `rollback` 호출
# DB 락
- 트랜잭션을 시작하고 아직 커밋을 수행하지 않았는데 다른 세션에서 같은 데이터를 수정하게 될 경우 격리성이 깨지게 됨
## 동작
![](https://i.imgur.com/2uCqZmg.png)
1. 세션1이 트랜잭션 시작
2. 세션1이 변경하려는 로우의 락을 획득 시도하며, 언락 상태일 경우 락을 얻음
3. 락을 획득하고 해당 로우에 update sql 수행
![](https://i.imgur.com/bWwOasu.png)
4. 세션2가 트랜잭션 시작
5. 세션2는 해당 로우의 락이 없으므로 락이 돌아올 때 까지 대기

> 락을 무한정 대기하지 않음
> 락 대기 시간을 넘어갈 경우 락 타임 오류 발생
![](https://i.imgur.com/ac1TuQy.png)
6. 세션1이 커밋을 수행하고, 트랜잭션이 종료되어 락 반납
![](https://i.imgur.com/MjxDRnM.png)
![](https://i.imgur.com/oGUMYGN.png)
7. 락을 대기하던 세션2가 락 획득
8. update sql 수행
9. 세션2가 커밋을 수행하고 트랜잭션이 종료되면 락 반납
## 조회 락
- 일반적으로 조회 락은 사용하지 않음
- 세션1에서 데이터를 조회한 다음에 이 데이터를 이용하여 애플리케이션에서 계산을 수행하여아 할 때 조회 시에 락 획득
![](https://i.imgur.com/75Z4Yd0.png)
- `select for update` 구문 사용
